# گزارش آزمایش 8 

## بخش اول

### انتخاب Adapter  
در این پروژه تصمیم بر استفاده از **الگوی Object Adapter** گرفته شد تا سه هدف اصلی محقق شود:

۱. **انعطاف‌پذیری زمان اجرا**  
با به‌کارگیری Object Adapter، امکان انتخاب یا تعویض پیاده‌سازی گراف (مثلاً JUNG یا JGraphT) در زمان اجرا فراهم می‌شود. به عبارت دیگر کافی است تنها نمونه‌ی Adapter مربوطه را تغییر دهیم تا کل سیستم بر پایه‌ی آن کار کند، بی‌آنکه نیازی به ویرایش یا کامپایل مجدد سایر کلاس‌ها باشد.

۲. **محدودیت‌های وراثت جاوا**  
جاوا از وراثت چندگانه پشتیبانی نمی‌کند؛ در حالی که Class Adapter بر مبنای وراثت مستقیم از یک کلاس گراف و یک interface کار می‌کند. با استفاده از ترکیب (composition) در Object Adapter، می‌توانیم بدون نیاز به وراثت چندگانه، همزمان رفتار interface مشترک و امکانات کلاس‌های concrete گراف را در یک Adapter گردآوری کنیم.

۳. **پنهان‌سازی جزئیات و کپسوله‌سازی**  
کلاس‌های traverser تنها با interface انتزاعی `GraphAdapter<V,E>` در ارتباط هستند، و هیچ‌گاه از جزئیات داخلی JUNG یا JGraphT مطلع نمی‌شوند. این کپسوله‌سازی تضمین می‌کند که تغییر یا ارتقای کتابخانه‌ی زیرساختی هیچ‌گاه به اصلاح کد traverser منجر نخواهد شد.

---

### نحوه پیاده سازی

#### تعریف رابط عمومی

برای جداسازی منطق traverser از پیاده‌سازی خاص گراف، یک interface عمومی با نام `GraphAdapter<V, E>` تعریف شده است. این interface چهار عملیات اصلی را در اختیار Adapterها قرار می‌دهد:

- `addVertex(V v)`: برای افزودن یک رأس به گراف  
- `addEdge(E e, V v1, V v2)`: برای افزودن یال بین دو رأس  
- `getNeighbors(V v)`: برای بازیابی لیست همسایه‌های یک رأس مشخص  
- `getVertices()`: برای دریافت تمام رئوس موجود در گراف  

این انتزاع باعث می‌شود کد traverser فقط به مفاهیم منطقی گراف وابسته باشد و هرگز با API خاص JGraphT یا JUNG درگیر نشود.

```java
public interface GraphAdapter<V,E> {
    void addVertex(V v);
    void addEdge(E e, V v1, V v2);
    Collection<V> getNeighbors(V v);
    Collection<V> getVertices();
}
```

#### نکات کلیدی پیاده‌سازی


**JGraphTGraphAdapter**  

در پیاده‌سازی مربوط به JGraphT، کلاس SimpleGraph مورد استفاده قرار گرفته است. هنگام افزودن یال، ابتدا بررسی می‌شود که دو رأس در گراف وجود داشته باشند یا نه. در صورت نبود، ابتدا آن‌ها افزوده می‌شوند و سپس یال ایجاد می‌شود:  

```java
internalGraph.addEdge(v1, v2);
```

**JungGraphAdapter**  

در سمت دیگر، پیاده‌سازی JUNG مبتنی بر کلاس SparseMultigraph است. در اینجا قبل از افزودن یال، بررسی می‌شود که آیا هر دو رأس قبلاً در گراف اضافه شده‌اند یا نه. اگر هر دو رأس موجود باشند، یال افزوده می‌شود:

```java
if (graph.containsVertex(v1) && graph.containsVertex(v2)) {
    graph.addEdge(edge, v1, v2);
}
```

این ساختار باعث شده که traverserها فقط با GraphAdapter کار کنند و از جزئیات هر کتابخانه بی‌اطلاع بمانند. در نتیجه، اگر در آینده نیاز باشد از کتابخانه‌ای جدید استفاده شود یا کتابخانه فعلی تغییر کند، تنها کافی‌ست یک Adapter جدید مطابق با همان interface نوشته شود و کل سیستم بدون تغییر در کلاس‌های دیگر با آن سازگار خواهد بود.



## بخش سوم

### سوال اول
استفاده از الگوی Strategy در این پروژه انتخاب مناسبی است، چون به ما امکان می‌دهد الگوریتم‌های مختلف پیمایش مانند DFS و BFS را از یکدیگر جدا و مستقل نگه داریم. به این ترتیب، هر الگوریتم به صورت یک "استراتژی" مجزا پیاده‌سازی شده و در نتیجه می‌توان آن‌ها را در زمان اجرا به راحتی با هم جایگزین کرد بدون نیاز به تغییر در ساختار گراف یا منطق اصلی برنامه.

این رویکرد باعث افزایش انعطاف‌پذیری کد و همچنین رعایت اصل Open/Closed در طراحی شی‌گرا می‌شود؛ یعنی برنامه برای اضافه کردن استراتژی‌های جدید باز است ولی نیازی به تغییر در بخش‌های قبلی ندارد.

### سوال دوم
برای پیاده‌سازی الگوی Strategy، ابتدا یک رابط (interface) به‌نام مثلاً ```GraphDisplayStrategy``` تعریف می‌شود که متدهایی مانند display(Graph g) را شامل شود. سپس برای هر روش نمایش (مثلاً ماتریس مجاورت، لیست مجاورت و ...) یک کلاس جداگانه پیاده‌سازی می‌شود که این رابط را پیاده می‌کند. در نهایت، کلاس اصلی گراف یک شی از نوع Strategy به عنوان فیلد نگه می‌دارد و در زمان نمایش از آن استفاده می‌کند.
